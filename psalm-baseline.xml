<?xml version="1.0" encoding="UTF-8"?>
<files psalm-version="5.17.0@c620f6e80d0abfca532b00bda366062aaedf6e5d">
  <file src="library/Mockery.php">
    <ArgumentTypeCoercion>
      <code>$demeterMockKey</code>
      <code>$newMockName</code>
    </ArgumentTypeCoercion>
    <DeprecatedClass>
      <code>MustBe</code>
      <code>new MustBe($expected)</code>
    </DeprecatedClass>
    <DeprecatedMethod>
      <code>self::builtInTypes()</code>
    </DeprecatedMethod>
    <DocblockTypeContradiction>
      <code>self::$_config === null</code>
      <code>self::$_generator === null</code>
      <code>self::$_loader === null</code>
    </DocblockTypeContradiction>
    <InternalMethod>
      <code>Reflector::isReservedWord($type)</code>
    </InternalMethod>
    <InvalidReturnStatement>
      <code>$argument</code>
      <code><![CDATA[$container->getMocks()[$demeterMockKey] ?? null]]></code>
      <code><![CDATA['...']]></code>
      <code><![CDATA[self::getContainer()->mock(...$args)->shouldIgnoreMissing()]]></code>
    </InvalidReturnStatement>
    <InvalidReturnType>
      <code><![CDATA[LegacyMockInterface&MockInterface&TSpy]]></code>
      <code>TArray</code>
      <code><![CDATA[null|(LegacyMockInterface&MockInterface&TMock)]]></code>
    </InvalidReturnType>
    <MissingClosureParamType>
      <code>$argument</code>
      <code>$method</code>
      <code>$n</code>
      <code>$nesting</code>
      <code>$object</code>
    </MissingClosureParamType>
    <MissingClosureReturnType>
      <code><![CDATA[static function ($argument) use (&$reference) {]]></code>
      <code>static function ($method) use ($add) {</code>
      <code>static function ($n) use ($mock) {</code>
      <code>static function ($object, $nesting) {</code>
    </MissingClosureReturnType>
    <MissingReturnType>
      <code>registerFileForCleanUp</code>
      <code>setGenerator</code>
      <code>setLoader</code>
    </MissingReturnType>
    <MissingThrowsDocblock>
      <code>getMethod</code>
      <code>mock</code>
      <code>mock</code>
      <code>mock</code>
      <code>mock</code>
      <code>mock</code>
      <code>mock</code>
      <code>mock</code>
      <code>mock</code>
      <code>mock</code>
      <code>mock</code>
      <code>mockery_teardown</code>
    </MissingThrowsDocblock>
    <MixedArgument>
      <code>$expectations</code>
      <code>$formatter($object, $nesting)</code>
      <code>$nesting</code>
      <code>$object</code>
      <code>$value</code>
    </MixedArgument>
    <MixedArgumentTypeCoercion>
      <code>$args</code>
      <code>$formattedArguments</code>
      <code>$k</code>
    </MixedArgumentTypeCoercion>
    <MixedArrayAssignment>
      <code>$argument[$key]</code>
      <code>$argument[$key]</code>
    </MixedArrayAssignment>
    <MixedArrayOffset>
      <code>$argument[$key]</code>
      <code>$argument[$key]</code>
    </MixedArrayOffset>
    <MixedAssignment>
      <code>$arg</code>
      <code>$argument</code>
      <code>$cleanedProperties[$name]</code>
      <code>$expectations</code>
      <code>$formattedArguments[]</code>
      <code>$key</code>
      <code>$reference</code>
      <code>$v</code>
      <code>$value</code>
      <code>$value</code>
      <code>$value</code>
    </MixedAssignment>
    <MixedInferredReturnType>
      <code>ExpectationInterface</code>
    </MixedInferredReturnType>
    <MixedOperand>
      <code>$argument</code>
    </MixedOperand>
    <MixedReturnStatement>
      <code>$expectations</code>
      <code>$expectations</code>
    </MixedReturnStatement>
    <NullableReturnStatement>
      <code>$expectations</code>
    </NullableReturnStatement>
    <PossiblyInvalidArgument>
      <code>$args</code>
      <code>$args</code>
      <code>$name</code>
    </PossiblyInvalidArgument>
    <PossiblyInvalidCast>
      <code>$name</code>
    </PossiblyInvalidCast>
    <PossiblyNullPropertyAssignmentValue>
      <code>null</code>
    </PossiblyNullPropertyAssignmentValue>
    <PossiblyNullReference>
      <code>allows</code>
      <code>mockery_getExpectationsFor</code>
    </PossiblyNullReference>
    <PossiblyUndefinedIntArrayOffset>
      <code>$args[0]</code>
    </PossiblyUndefinedIntArrayOffset>
    <PossiblyUndefinedMethod>
      <code>allows</code>
    </PossiblyUndefinedMethod>
    <PossiblyUnusedMethod>
      <code>andAnyOtherArgs</code>
      <code>andAnyOthers</code>
      <code>any</code>
      <code>anyOf</code>
      <code>capture</code>
      <code>contains</code>
      <code>ducktype</code>
      <code>fetchMock</code>
      <code>globalHelpers</code>
      <code>hasKey</code>
      <code>hasValue</code>
      <code>instanceMock</code>
      <code>isBuiltInType</code>
      <code>isEqual</code>
      <code>isSame</code>
      <code>mustBe</code>
      <code>not</code>
      <code>notAnyOf</code>
      <code>on</code>
      <code>parseShouldReturnArgs</code>
      <code>pattern</code>
      <code>resetContainer</code>
      <code>setContainer</code>
      <code>setGenerator</code>
      <code>setLoader</code>
      <code>subset</code>
      <code>type</code>
    </PossiblyUnusedMethod>
    <PossiblyUnusedReturnValue>
      <code>LegacyMockInterface|MockInterface</code>
    </PossiblyUnusedReturnValue>
    <RedundantConditionGivenDocblockType>
      <code>$parentMock !== null</code>
    </RedundantConditionGivenDocblockType>
    <UnresolvableInclude>
      <code>require $fileName</code>
    </UnresolvableInclude>
  </file>
  <file src="library/Mockery/Adapter/Phpunit/MockeryPHPUnitIntegration.php">
    <InternalMethod>
      <code>addToAssertionCount</code>
    </InternalMethod>
    <MissingPropertyType>
      <code>$mockeryOpen</code>
    </MissingPropertyType>
    <MissingReturnType>
      <code>addMockeryExpectationsToAssertionCount</code>
      <code>checkMockeryExceptions</code>
      <code>closeMockery</code>
      <code>mockeryAssertPostConditions</code>
      <code>purgeMockeryContainer</code>
      <code>startMockery</code>
    </MissingReturnType>
    <PossiblyUnusedMethod>
      <code>purgeMockeryContainer</code>
      <code>startMockery</code>
    </PossiblyUnusedMethod>
    <UndefinedAttributeClass>
      <code>After</code>
      <code>Before</code>
    </UndefinedAttributeClass>
    <UndefinedInterfaceMethod>
      <code>dismissed</code>
    </UndefinedInterfaceMethod>
  </file>
  <file src="library/Mockery/Adapter/Phpunit/MockeryTestCase.php">
    <MissingReturnType>
      <code>mockeryTestSetUp</code>
      <code>mockeryTestTearDown</code>
    </MissingReturnType>
  </file>
  <file src="library/Mockery/Adapter/Phpunit/TestListener.php">
    <DeprecatedInterface>
      <code>TestListener</code>
    </DeprecatedInterface>
    <DeprecatedTrait>
      <code>TestListenerDefaultImplementation</code>
    </DeprecatedTrait>
    <MissingPropertyType>
      <code>$trait</code>
    </MissingPropertyType>
    <MixedMethodCall>
      <code>endTest</code>
      <code>startTestSuite</code>
    </MixedMethodCall>
    <UnusedClass>
      <code>TestListener</code>
    </UnusedClass>
  </file>
  <file src="library/Mockery/Adapter/Phpunit/TestListenerTrait.php">
    <DeprecatedClass>
      <code><![CDATA[Blacklist::addDirectory(dirname((new ReflectionClass(Mockery::class))->getFileName()))]]></code>
      <code>Blacklist::class</code>
      <code>new Blacklist()</code>
    </DeprecatedClass>
    <InternalClass>
      <code>BaseTestRunner::STATUS_PASSED</code>
      <code><![CDATA[new ExpectationFailedException(
            sprintf(
                "Mockery's expectations have not been verified. Make sure that \Mockery::close() is called at the end of the test. Consider using %s\MockeryPHPUnitIntegration or extending %s\MockeryTestCase.",
                __NAMESPACE__,
                __NAMESPACE__
            )
        )]]></code>
    </InternalClass>
    <InternalMethod>
      <code>addFailure</code>
      <code>getTestResultObject</code>
      <code><![CDATA[new ExpectationFailedException(
            sprintf(
                "Mockery's expectations have not been verified. Make sure that \Mockery::close() is called at the end of the test. Consider using %s\MockeryPHPUnitIntegration or extending %s\MockeryTestCase.",
                __NAMESPACE__,
                __NAMESPACE__
            )
        )]]></code>
    </InternalMethod>
    <MissingReturnType>
      <code>endTest</code>
      <code>startTestSuite</code>
    </MissingReturnType>
    <MissingThrowsDocblock>
      <code>getBlacklistedDirectories</code>
    </MissingThrowsDocblock>
    <PossiblyUnusedMethod>
      <code>endTest</code>
      <code>startTestSuite</code>
    </PossiblyUnusedMethod>
    <RedundantConditionGivenDocblockType>
      <code>$result !== null</code>
    </RedundantConditionGivenDocblockType>
    <UndefinedPropertyAssignment>
      <code>Blacklist::$blacklistedClassNames</code>
    </UndefinedPropertyAssignment>
    <UndefinedPropertyFetch>
      <code>Blacklist::$blacklistedClassNames</code>
    </UndefinedPropertyFetch>
  </file>
  <file src="library/Mockery/CompositeExpectation.php">
    <InvalidCast>
      <code>$expectation</code>
    </InvalidCast>
    <InvalidPropertyAssignmentValue>
      <code><![CDATA[$this->_expectations]]></code>
    </InvalidPropertyAssignmentValue>
    <InvalidReturnStatement>
      <code><![CDATA[$first->getMock()]]></code>
    </InvalidReturnStatement>
    <InvalidReturnType>
      <code><![CDATA[LegacyMockInterface&MockInterface]]></code>
    </InvalidReturnType>
    <LessSpecificReturnStatement>
      <code><![CDATA[$first->getMock()->shouldNotReceive(...$args)]]></code>
      <code><![CDATA[$first->getMock()->shouldReceive(...$args)]]></code>
      <code><![CDATA[$this->andReturn(...$args)]]></code>
    </LessSpecificReturnStatement>
    <MixedArgument>
      <code>$args</code>
      <code>$args</code>
    </MixedArgument>
    <MoreSpecificReturnType>
      <code>Expectation</code>
      <code>Expectation</code>
      <code>self</code>
    </MoreSpecificReturnType>
    <PossiblyUnusedMethod>
      <code>mock</code>
      <code>shouldNotReceive</code>
      <code>shouldReceive</code>
    </PossiblyUnusedMethod>
  </file>
  <file src="library/Mockery/Configuration.php">
    <MissingPropertyType>
      <code>$_reflectionCacheEnabled</code>
    </MissingPropertyType>
    <MixedArgument>
      <code>$type</code>
      <code>Hamcrest_Matcher::class</code>
    </MixedArgument>
    <MixedAssignment>
      <code>$type</code>
    </MixedAssignment>
    <MixedInferredReturnType>
      <code>bool</code>
    </MixedInferredReturnType>
    <MixedReturnStatement>
      <code><![CDATA[$this->_reflectionCacheEnabled]]></code>
    </MixedReturnStatement>
    <PossiblyUndefinedVariable>
      <code>$classes</code>
    </PossiblyUndefinedVariable>
    <PossiblyUnusedMethod>
      <code>allowMockingMethodsUnnecessarily</code>
      <code>allowMockingNonExistentMethods</code>
      <code>disableReflectionCache</code>
      <code>enableReflectionCache</code>
      <code>getDefaultMatcher</code>
      <code>getInternalClassMethodParamMap</code>
      <code>mockingMethodsUnnecessarilyAllowed</code>
      <code>reflectionCacheEnabled</code>
      <code>resetInternalClassMethodParamMaps</code>
      <code>setConstantsMap</code>
      <code>setDefaultMatcher</code>
      <code>setInternalClassMethodParamMap</code>
      <code>setObjectFormatter</code>
    </PossiblyUnusedMethod>
    <PropertyTypeCoercion>
      <code><![CDATA[$this->_internalClassParamMap]]></code>
      <code><![CDATA[$this->_internalClassParamMap]]></code>
    </PropertyTypeCoercion>
    <RedundantCastGivenDocblockType>
      <code>(bool) $flag</code>
      <code>(bool) $flag</code>
    </RedundantCastGivenDocblockType>
    <UndefinedClass>
      <code>Hamcrest_Matcher</code>
    </UndefinedClass>
  </file>
  <file src="library/Mockery/Container.php">
    <ArgumentTypeCoercion>
      <code>$constructorArgs</code>
      <code>$interfaces</code>
      <code>$mock</code>
      <code>$type</code>
      <code><![CDATA['stdClass']]></code>
      <code><![CDATA['stdClass']]></code>
    </ArgumentTypeCoercion>
    <DocblockTypeContradiction>
      <code>$match === false</code>
      <code>array_keys($arg) !== range(0, count($arg) - 1)</code>
    </DocblockTypeContradiction>
    <InvalidArgument>
      <code>$arg</code>
    </InvalidArgument>
    <InvalidArrayOffset>
      <code>$mocks[$index]</code>
    </InvalidArrayOffset>
    <InvalidCast>
      <code>$arg</code>
    </InvalidCast>
    <InvalidReturnStatement>
      <code><![CDATA[$this->rememberMock($mock)]]></code>
    </InvalidReturnStatement>
    <InvalidReturnType>
      <code><![CDATA[LegacyMockInterface&MockInterface&TMock]]></code>
    </InvalidReturnType>
    <LessSpecificReturnStatement>
      <code><![CDATA[$this->_mocks[$reference] ?? null]]></code>
    </LessSpecificReturnStatement>
    <MissingParamType>
      <code>$config</code>
    </MissingParamType>
    <MissingReturnType>
      <code>checkForNamedMockClashes</code>
      <code>mockery_teardown</code>
      <code>mockery_validateOrder</code>
      <code>mockery_verify</code>
    </MissingReturnType>
    <MissingThrowsDocblock>
      <code><![CDATA[throw new Exception(
                sprintf("The mock named '%s' has been already defined with a different mock configuration", $name)
            );]]></code>
    </MissingThrowsDocblock>
    <MixedArgument>
      <code>$className</code>
      <code>$className</code>
      <code>$def</code>
      <code>$name</code>
      <code>$name</code>
    </MixedArgument>
    <MixedArgumentTypeCoercion>
      <code>$keys</code>
    </MixedArgumentTypeCoercion>
    <MixedArrayAccess>
      <code>$arg[self::BLOCKS]</code>
    </MixedArrayAccess>
    <MixedArrayOffset>
      <code><![CDATA[$this->_namedMocks[$name]]]></code>
    </MixedArrayOffset>
    <MixedAssignment>
      <code>$blocks</code>
      <code>$className</code>
      <code>$def</code>
      <code>$exception</code>
      <code>$exceptions[]</code>
      <code>$hash</code>
      <code>$name</code>
    </MixedAssignment>
    <MixedInferredReturnType>
      <code>LegacyMockInterface|MockInterface</code>
    </MixedInferredReturnType>
    <MixedMethodCall>
      <code>atLeast</code>
      <code>byDefault</code>
      <code>getClassName</code>
      <code>getHash</code>
      <code>getName</code>
      <code>mockery_init</code>
      <code>new $internalMockName()</code>
      <code>once</code>
      <code>shouldReceive</code>
      <code>shouldReceive</code>
    </MixedMethodCall>
    <MixedPropertyTypeCoercion>
      <code><![CDATA[$this->_namedMocks]]></code>
    </MixedPropertyTypeCoercion>
    <MixedReturnStatement>
      <code>$mocks[$index]</code>
    </MixedReturnStatement>
    <MixedReturnTypeCoercion>
      <code>$exceptions</code>
      <code><![CDATA[array<Throwable>]]></code>
    </MixedReturnTypeCoercion>
    <MoreSpecificReturnType>
      <code><![CDATA[null|(LegacyMockInterface&MockInterface&TMock)]]></code>
    </MoreSpecificReturnType>
    <NoValue>
      <code>$arg</code>
      <code>$arg</code>
      <code>$arg</code>
      <code>$constructorArgs</code>
      <code>$quickDefinitions</code>
    </NoValue>
    <PossiblyUndefinedIntArrayOffset>
      <code>$parts[1]</code>
    </PossiblyUndefinedIntArrayOffset>
    <PossiblyUndefinedMethod>
      <code>mockery_thrownExceptions</code>
    </PossiblyUndefinedMethod>
    <PossiblyUnusedMethod>
      <code>instanceMock</code>
      <code>mockery_allocateOrder</code>
      <code>mockery_getCurrentOrder</code>
      <code>mockery_getGroups</code>
      <code>mockery_setGroup</code>
    </PossiblyUnusedMethod>
    <PossiblyUnusedReturnValue>
      <code>int</code>
    </PossiblyUnusedReturnValue>
    <PropertyTypeCoercion>
      <code><![CDATA[$this->_mocks]]></code>
      <code><![CDATA[$this->_mocks]]></code>
    </PropertyTypeCoercion>
    <RedundantConditionGivenDocblockType>
      <code><![CDATA[is_callable($finalArg) && is_object($finalArg)]]></code>
      <code>is_object($arg)</code>
      <code>is_object($finalArg)</code>
    </RedundantConditionGivenDocblockType>
    <TypeDoesNotContainType>
      <code>$constructorArgs !== null</code>
    </TypeDoesNotContainType>
  </file>
  <file src="library/Mockery/CountValidator/CountValidatorAbstract.php">
    <PossiblyNullPropertyAssignmentValue>
      <code>null</code>
      <code>null</code>
    </PossiblyNullPropertyAssignmentValue>
    <PossiblyUnusedMethod>
      <code>__construct</code>
    </PossiblyUnusedMethod>
  </file>
  <file src="library/Mockery/CountValidator/CountValidatorInterface.php">
    <PossiblyUnusedMethod>
      <code>isEligible</code>
      <code>validate</code>
    </PossiblyUnusedMethod>
  </file>
  <file src="library/Mockery/CountValidator/Exact.php">
    <PossiblyNullOperand>
      <code><![CDATA[$this->_expectation->getExceptionMessage()]]></code>
    </PossiblyNullOperand>
  </file>
  <file src="library/Mockery/Exception/BadMethodCallException.php">
    <MissingReturnType>
      <code>dismiss</code>
    </MissingReturnType>
    <UnusedClass>
      <code>BadMethodCallException</code>
    </UnusedClass>
  </file>
  <file src="library/Mockery/Exception/InvalidArgumentException.php">
    <UnusedClass>
      <code>InvalidArgumentException</code>
    </UnusedClass>
  </file>
  <file src="library/Mockery/Exception/InvalidCountException.php">
    <MissingThrowsDocblock>
      <code><![CDATA[throw new RuntimeException('Illegal comparative for expected call counts set: ' . $comp);]]></code>
    </MissingThrowsDocblock>
    <PossiblyUnusedMethod>
      <code>getActualCount</code>
      <code>getExpectedCount</code>
      <code>getExpectedCountComparative</code>
      <code>getMethodName</code>
      <code>getMockName</code>
    </PossiblyUnusedMethod>
  </file>
  <file src="library/Mockery/Exception/InvalidOrderException.php">
    <PossiblyUnusedMethod>
      <code>getActualOrder</code>
      <code>getExpectedOrder</code>
      <code>getMethodName</code>
      <code>getMockName</code>
    </PossiblyUnusedMethod>
  </file>
  <file src="library/Mockery/Exception/NoMatchingExpectationException.php">
    <PossiblyUnusedMethod>
      <code>getActualArguments</code>
      <code>getMethodName</code>
      <code>getMockName</code>
    </PossiblyUnusedMethod>
  </file>
  <file src="library/Mockery/Expectation.php">
    <DocblockTypeContradiction>
      <code>! is_int($index)</code>
      <code>$group === null</code>
      <code>$mock instanceof $mockClass</code>
      <code>is_int($limit)</code>
    </DocblockTypeContradiction>
    <InvalidArgument>
      <code>$argsOrClosure</code>
    </InvalidArgument>
    <InvalidStringClass>
      <code>new $exception($message, $code, $previous)</code>
      <code><![CDATA[new $this->_countValidatorClass($this, $limit)]]></code>
    </InvalidStringClass>
    <MissingClosureParamType>
      <code>$args</code>
      <code>$args</code>
    </MissingClosureParamType>
    <MissingClosureReturnType>
      <code>static function () use ($args) {</code>
      <code>static function (...$args) use ($index) {</code>
    </MissingClosureReturnType>
    <MissingParamType>
      <code>$code</code>
      <code>$exception</code>
      <code>$message</code>
    </MissingParamType>
    <MissingReturnType>
      <code>andThrows</code>
      <code>between</code>
      <code>getName</code>
    </MissingReturnType>
    <MissingThrowsDocblock>
      <code>evaluate</code>
      <code>evaluate</code>
      <code>makeExpectationDefault</code>
      <code>mockery_validateOrder</code>
      <code>mockery_validateOrder</code>
      <code><![CDATA[throw new Exception(
                'Mock Objects not created from a loaded/existing class are incapable of passing method calls through to a parent class'
            );]]></code>
      <code><![CDATA[throw new InvalidArgumentException(
                'Invalid argument index supplied. Index must be a non-negative integer.'
            );]]></code>
      <code><![CDATA[throw new InvalidArgumentException(sprintf(
            'Call to %s with an invalid argument (%s), only array and closure are allowed',
            __METHOD__,
            $argsOrClosure
        ));]]></code>
      <code>times</code>
      <code>times</code>
      <code>times</code>
      <code>times</code>
      <code>times</code>
    </MissingThrowsDocblock>
    <MixedArgument>
      <code>$code</code>
      <code>$exception</code>
      <code>$groups</code>
      <code>$message</code>
      <code>$return</code>
      <code>$values</code>
      <code>func_get_args()</code>
      <code>func_get_args()</code>
    </MixedArgument>
    <MixedArgumentTypeCoercion>
      <code>$firstCorrespondingKey</code>
    </MixedArgumentTypeCoercion>
    <MixedArrayAccess>
      <code>$groups[$group]</code>
    </MixedArrayAccess>
    <MixedAssignment>
      <code>$arg</code>
      <code>$expectedArg</code>
      <code>$groups</code>
      <code>$lastExpectedArgument</code>
      <code>$newValidators[]</code>
      <code>$result</code>
      <code>$return</code>
      <code>$validator</code>
      <code>$validator</code>
      <code>$validator</code>
      <code>$value</code>
      <code>$values</code>
    </MixedAssignment>
    <MixedClone>
      <code>clone $validator</code>
    </MixedClone>
    <MixedFunctionCall>
      <code><![CDATA[array_shift($this->_closureQueue)(...$args)]]></code>
      <code><![CDATA[current($this->_closureQueue)(...$args)]]></code>
    </MixedFunctionCall>
    <MixedInferredReturnType>
      <code>bool</code>
      <code>int</code>
    </MixedInferredReturnType>
    <MixedMethodCall>
      <code>isEligible</code>
      <code>mockery_allocateOrder</code>
      <code>mockery_allocateOrder</code>
      <code>mockery_getGroups</code>
      <code>mockery_setGroup</code>
      <code>validate</code>
    </MixedMethodCall>
    <MixedReturnStatement>
      <code>$groups[$group]</code>
      <code><![CDATA[$ordering->mockery_allocateOrder()]]></code>
      <code>$result</code>
    </MixedReturnStatement>
    <PossiblyFalseArgument>
      <code>$firstCorrespondingKey</code>
    </PossiblyFalseArgument>
    <PossiblyInvalidFunctionCall>
      <code><![CDATA[current($this->_closureQueue)(...$args)]]></code>
    </PossiblyInvalidFunctionCall>
    <PossiblyNullArgument>
      <code>$group</code>
      <code>$group</code>
    </PossiblyNullArgument>
    <PossiblyNullFunctionCall>
      <code><![CDATA[array_shift($this->_closureQueue)(...$args)]]></code>
    </PossiblyNullFunctionCall>
    <PossiblyNullPropertyAssignmentValue>
      <code>null</code>
      <code>null</code>
      <code>null</code>
      <code>null</code>
    </PossiblyNullPropertyAssignmentValue>
    <PossiblyUndefinedIntArrayOffset>
      <code><![CDATA[$this->_expectedArgs[0]]]></code>
      <code><![CDATA[$this->_expectedArgs[0]]]></code>
    </PossiblyUndefinedIntArrayOffset>
    <PossiblyUnusedMethod>
      <code>__construct</code>
      <code>andReturnArg</code>
      <code>andReturnFalse</code>
      <code>andReturnNull</code>
      <code>andReturnSelf</code>
      <code>andReturnTrue</code>
      <code>andReturnUndefined</code>
      <code>andReturnUsing</code>
      <code>andThrowExceptions</code>
      <code>andThrows</code>
      <code>andYield</code>
      <code>because</code>
      <code>between</code>
      <code>byDefault</code>
      <code>globally</code>
      <code>isCallCountConstrained</code>
      <code>isEligible</code>
      <code>once</code>
      <code>ordered</code>
      <code>passthru</code>
      <code>set</code>
      <code>twice</code>
      <code>with</code>
      <code>withSomeOfArgs</code>
      <code>zeroOrMoreTimes</code>
    </PossiblyUnusedMethod>
    <PossiblyUnusedProperty>
      <code>$_returnValue</code>
    </PossiblyUnusedProperty>
    <PossiblyUnusedReturnValue>
      <code>mixed</code>
    </PossiblyUnusedReturnValue>
    <RedundantConditionGivenDocblockType>
      <code>$argsOrClosure instanceof Closure</code>
    </RedundantConditionGivenDocblockType>
    <TooManyArguments>
      <code>mockery_validateOrder</code>
    </TooManyArguments>
    <UndefinedClass>
      <code>Hamcrest_Matcher</code>
    </UndefinedClass>
    <UndefinedInterfaceMethod>
      <code>mockery_callSubjectMethod</code>
      <code>mockery_isInstance</code>
      <code>mockery_returnValueForMethod</code>
    </UndefinedInterfaceMethod>
    <UnusedMethod>
      <code>isAndAnyOtherArgumentsMatcher</code>
    </UnusedMethod>
  </file>
  <file src="library/Mockery/ExpectationDirector.php">
    <MissingReturnType>
      <code>addExpectation</code>
    </MissingReturnType>
    <MissingThrowsDocblock>
      <code>throw $exception;</code>
    </MissingThrowsDocblock>
    <MixedMethodCall>
      <code>verifyCall</code>
    </MixedMethodCall>
    <PossiblyNullPropertyAssignmentValue>
      <code>null</code>
      <code>null</code>
      <code>null</code>
    </PossiblyNullPropertyAssignmentValue>
    <PossiblyUnusedMethod>
      <code>__construct</code>
      <code>addExpectation</code>
      <code>call</code>
      <code>getExpectationCount</code>
      <code>verify</code>
    </PossiblyUnusedMethod>
    <PossiblyUnusedProperty>
      <code>$_expectedOrder</code>
    </PossiblyUnusedProperty>
    <UndefinedInterfaceMethod>
      <code>isCallCountConstrained</code>
      <code>isEligible</code>
      <code>matchArgs</code>
      <code>matchArgs</code>
      <code>verify</code>
      <code>verify</code>
    </UndefinedInterfaceMethod>
  </file>
  <file src="library/Mockery/ExpectationInterface.php">
    <PossiblyUnusedMethod>
      <code>andReturns</code>
    </PossiblyUnusedMethod>
  </file>
  <file src="library/Mockery/ExpectsHigherOrderMessage.php">
    <MixedInferredReturnType>
      <code>Expectation|ExpectationInterface|HigherOrderMessage</code>
    </MixedInferredReturnType>
    <MixedReturnStatement>
      <code><![CDATA[$expectation->once()]]></code>
    </MixedReturnStatement>
    <PossiblyUnusedMethod>
      <code>__construct</code>
    </PossiblyUnusedMethod>
    <UndefinedInterfaceMethod>
      <code>once</code>
    </UndefinedInterfaceMethod>
    <UndefinedMagicMethod>
      <code>once</code>
    </UndefinedMagicMethod>
  </file>
  <file src="library/Mockery/Generator/CachingGenerator.php">
    <MixedInferredReturnType>
      <code>string</code>
    </MixedInferredReturnType>
    <MixedPropertyTypeCoercion>
      <code><![CDATA[$this->cache]]></code>
    </MixedPropertyTypeCoercion>
    <MixedReturnStatement>
      <code><![CDATA[$this->cache[$hash] = $this->generator->generate($config)]]></code>
    </MixedReturnStatement>
  </file>
  <file src="library/Mockery/Generator/DefinedTargetClass.php">
    <LessSpecificReturnStatement>
      <code><![CDATA[array_unique(
            array_merge(
                ['\AllowDynamicProperties'],
                array_map(
                    static function (ReflectionAttribute $attribute): string {
                        return '\\' . $attribute->getName();
                    },
                    $this->rfc->getAttributes()
                )
            )
        )]]></code>
    </LessSpecificReturnStatement>
    <MixedArgument>
      <code><![CDATA[$this->rfc->getAttributes()]]></code>
    </MixedArgument>
    <MixedOperand>
      <code><![CDATA[$attribute->getName()]]></code>
    </MixedOperand>
    <MoreSpecificImplementedParamType>
      <code>$interface</code>
    </MoreSpecificImplementedParamType>
    <MoreSpecificReturnType>
      <code><![CDATA[list<class-string>]]></code>
    </MoreSpecificReturnType>
  </file>
  <file src="library/Mockery/Generator/Generator.php">
    <MissingReturnType>
      <code>generate</code>
    </MissingReturnType>
  </file>
  <file src="library/Mockery/Generator/Method.php">
    <PossiblyUnusedMethod>
      <code>__call</code>
    </PossiblyUnusedMethod>
  </file>
  <file src="library/Mockery/Generator/MockConfiguration.php">
    <ArgumentTypeCoercion>
      <code>$target</code>
      <code>$target</code>
      <code>$targetInterface</code>
      <code>$targetTrait</code>
      <code>$targets</code>
      <code><![CDATA[$this->targetClassName]]></code>
      <code><![CDATA['\\Iterator']]></code>
      <code><![CDATA['\\IteratorAggregate']]></code>
      <code><![CDATA['\\IteratorAggregate']]></code>
    </ArgumentTypeCoercion>
    <InvalidArgument>
      <code>$targets</code>
    </InvalidArgument>
    <InvalidPropertyAssignmentValue>
      <code><![CDATA[$this->targetTraits]]></code>
      <code><![CDATA[array_unique($this->targetTraits)]]></code>
    </InvalidPropertyAssignmentValue>
    <LessSpecificReturnStatement>
      <code><![CDATA[$this->allMethods = $methods]]></code>
      <code><![CDATA[$this->targetInterfaces]]></code>
      <code><![CDATA[$this->targetInterfaces = array_unique($this->targetInterfaces)]]></code>
      <code><![CDATA[$this->targetTraits]]></code>
      <code><![CDATA[$this->targetTraits]]></code>
      <code><![CDATA[array_filter($methods, static function ($method) use ($whitelist) {
                if ($method->isAbstract()) {
                    return true;
                }

                return in_array(strtolower($method->getName()), $whitelist, true);
            })]]></code>
    </LessSpecificReturnStatement>
    <MissingPropertyType>
      <code>$blackListedMethods</code>
      <code>$constantsMap</code>
    </MissingPropertyType>
    <MissingReturnType>
      <code>addTarget</code>
      <code>addTargetInterfaceName</code>
      <code>addTargetTraitName</code>
      <code>addTargets</code>
      <code>setTargetClassName</code>
      <code>setTargetObject</code>
    </MissingReturnType>
    <MissingThrowsDocblock>
      <code><![CDATA[throw new Exception(
                    'The class ' . $this->targetClassName . ' is marked final and its methods'
                    . ' cannot be replaced. Classes marked final can be passed in'
                    . ' to \Mockery::mock() as instantiated objects to create a'
                    . ' partial mock, but only if the mock is not subject to type'
                    . ' hinting checks.'
                );]]></code>
    </MissingThrowsDocblock>
    <MixedArgument>
      <code>$alias</code>
      <code>$alias</code>
      <code><![CDATA[$this->blackListedMethods]]></code>
      <code><![CDATA[$this->constantsMap]]></code>
    </MixedArgument>
    <MixedAssignment>
      <code>$alias</code>
    </MixedAssignment>
    <MixedInferredReturnType>
      <code><![CDATA[array<string,scalar|array<scalar>>]]></code>
      <code><![CDATA[array<string>]]></code>
    </MixedInferredReturnType>
    <MixedMethodCall>
      <code>addPart</code>
      <code>build</code>
    </MixedMethodCall>
    <MixedReturnStatement>
      <code><![CDATA[$this->blackListedMethods]]></code>
      <code><![CDATA[$this->constantsMap]]></code>
    </MixedReturnStatement>
    <MoreSpecificReturnType>
      <code><![CDATA[list<Method>]]></code>
      <code><![CDATA[list<Method>]]></code>
      <code><![CDATA[list<TargetClassInterface>]]></code>
      <code><![CDATA[list<TargetClassInterface>]]></code>
    </MoreSpecificReturnType>
    <PossiblyNullArgument>
      <code><![CDATA[$this->getName()]]></code>
      <code><![CDATA[$this->getName()]]></code>
    </PossiblyNullArgument>
    <PossiblyNullReference>
      <code>getMethods</code>
    </PossiblyNullReference>
    <PossiblyUndefinedIntArrayOffset>
      <code>$params[1]</code>
    </PossiblyUndefinedIntArrayOffset>
    <PossiblyUnusedMethod>
      <code>getParameterOverrides</code>
    </PossiblyUnusedMethod>
    <PropertyTypeCoercion>
      <code>$methods</code>
    </PropertyTypeCoercion>
  </file>
  <file src="library/Mockery/Generator/MockConfigurationBuilder.php">
    <MissingParamType>
      <code>$whiteListedMethod</code>
    </MissingParamType>
    <MissingReturnType>
      <code>setInstanceMock</code>
      <code>setMockOriginalDestructor</code>
      <code>setName</code>
    </MissingReturnType>
    <MixedArgumentTypeCoercion>
      <code><![CDATA[$this->constantsMap]]></code>
      <code><![CDATA[$this->parameterOverrides]]></code>
      <code><![CDATA[$this->targets]]></code>
      <code><![CDATA[$this->whiteListedMethods]]></code>
    </MixedArgumentTypeCoercion>
    <MixedAssignment>
      <code>$method</code>
    </MixedAssignment>
    <PossiblyUnusedMethod>
      <code>addWhiteListedMethods</code>
      <code>setBlackListedMethods</code>
      <code>setWhiteListedMethods</code>
    </PossiblyUnusedMethod>
    <PropertyNotSetInConstructor>
      <code>$name</code>
    </PropertyNotSetInConstructor>
    <PropertyTypeCoercion>
      <code><![CDATA[array_diff($this->blackListedMethods, $this->php7SemiReservedKeywords)]]></code>
    </PropertyTypeCoercion>
    <RedundantCastGivenDocblockType>
      <code>(bool) $instanceMock</code>
      <code>(bool) $mockDestructor</code>
    </RedundantCastGivenDocblockType>
  </file>
  <file src="library/Mockery/Generator/MockDefinition.php">
    <InvalidNullableReturnType>
      <code>string</code>
    </InvalidNullableReturnType>
    <NullableReturnStatement>
      <code><![CDATA[$this->config->getName()]]></code>
    </NullableReturnStatement>
    <PossiblyUnusedMethod>
      <code>getConfig</code>
    </PossiblyUnusedMethod>
  </file>
  <file src="library/Mockery/Generator/MockNameBuilder.php">
    <MissingReturnType>
      <code>addPart</code>
    </MissingReturnType>
  </file>
  <file src="library/Mockery/Generator/Parameter.php">
    <InvalidArgument>
      <code>false</code>
    </InvalidArgument>
    <InvalidReturnStatement>
      <code>class_exists($typeHint) ? DefinedTargetClass::factory($typeHint, false) : null</code>
    </InvalidReturnStatement>
    <InvalidReturnType>
      <code>null|ReflectionClass</code>
    </InvalidReturnType>
    <PossiblyNullArgument>
      <code>$typeHint</code>
    </PossiblyNullArgument>
    <PossiblyUnusedMethod>
      <code>__call</code>
      <code>getClass</code>
      <code>getTypeHintAsString</code>
    </PossiblyUnusedMethod>
  </file>
  <file src="library/Mockery/Generator/StringManipulation/Pass/ClassPass.php">
    <ArgumentTypeCoercion>
      <code>$className</code>
    </ArgumentTypeCoercion>
  </file>
  <file src="library/Mockery/Generator/StringManipulation/Pass/ConstantsPass.php">
    <MixedAssignment>
      <code>$value</code>
    </MixedAssignment>
    <PossiblyInvalidIterator>
      <code>$cm[$name]</code>
    </PossiblyInvalidIterator>
    <PossiblyNullArgument>
      <code>$name</code>
    </PossiblyNullArgument>
  </file>
  <file src="library/Mockery/Generator/StringManipulation/Pass/InstanceMockPass.php">
    <MissingParamType>
      <code>$class</code>
      <code>$code</code>
    </MissingParamType>
    <MissingReturnType>
      <code>appendToClass</code>
    </MissingReturnType>
    <MixedArgument>
      <code>$class</code>
      <code>$class</code>
    </MixedArgument>
    <MixedInferredReturnType>
      <code>string</code>
    </MixedInferredReturnType>
    <MixedOperand>
      <code>$code</code>
    </MixedOperand>
    <MixedReturnStatement>
      <code><![CDATA[$this->appendToClass($code, static::INSTANCE_MOCK_CODE)]]></code>
    </MixedReturnStatement>
    <PossiblyFalseArgument>
      <code>$lastBrace</code>
    </PossiblyFalseArgument>
  </file>
  <file src="library/Mockery/Generator/StringManipulation/Pass/InterfacePass.php">
    <ArgumentTypeCoercion>
      <code>$name</code>
    </ArgumentTypeCoercion>
    <MixedArgument>
      <code><![CDATA[$i->getName()]]></code>
    </MixedArgument>
    <MixedMethodCall>
      <code>getName</code>
    </MixedMethodCall>
    <MixedOperand>
      <code>$code</code>
    </MixedOperand>
  </file>
  <file src="library/Mockery/Generator/StringManipulation/Pass/MagicMethodTypeHintsPass.php">
    <ArgumentTypeCoercion>
      <code><![CDATA[$this->getDeclarationRegex($method->getName())]]></code>
      <code><![CDATA[$this->getDeclarationRegex($method->getName())]]></code>
      <code><![CDATA[$this->getDeclarationRegex($method->getName())]]></code>
    </ArgumentTypeCoercion>
    <InvalidArgument>
      <code>$code</code>
      <code>$code</code>
      <code>$code</code>
      <code>$code</code>
    </InvalidArgument>
    <InvalidReturnStatement>
      <code>$code</code>
    </InvalidReturnStatement>
    <InvalidReturnType>
      <code>string</code>
    </InvalidReturnType>
    <MissingReturnType>
      <code>renderTypeHint</code>
    </MissingReturnType>
    <MixedArgument>
      <code>$method</code>
    </MixedArgument>
    <MixedAssignment>
      <code>$method</code>
      <code>$name</code>
    </MixedAssignment>
    <MixedOperand>
      <code>$name</code>
      <code><![CDATA[$this->renderTypeHint($parameter)]]></code>
    </MixedOperand>
    <PossiblyUndefinedIntArrayOffset>
      <code>$matches[0]</code>
    </PossiblyUndefinedIntArrayOffset>
  </file>
  <file src="library/Mockery/Generator/StringManipulation/Pass/MethodDefinitionPass.php">
    <InvalidCast>
      <code>$param</code>
    </InvalidCast>
    <InvalidMethodCall>
      <code>getName</code>
      <code>isPassedByReference</code>
    </InvalidMethodCall>
    <MissingParamType>
      <code>$class</code>
      <code>$code</code>
      <code>$config</code>
      <code>$config</code>
      <code>$method</code>
    </MissingParamType>
    <MissingReturnType>
      <code>appendToClass</code>
      <code>renderMethodBody</code>
      <code>renderParams</code>
      <code>renderReturnType</code>
      <code>renderTypeHint</code>
    </MissingReturnType>
    <MixedArgument>
      <code>$class</code>
      <code>$class</code>
      <code><![CDATA[$class->getName()]]></code>
      <code><![CDATA[$method->getParameters()]]></code>
      <code><![CDATA[$overrides[$class_name][$method->getName()]]]></code>
      <code><![CDATA[$overrides[strtolower($class->getName())][$method->getName()]]]></code>
    </MixedArgument>
    <MixedArgumentTypeCoercion>
      <code>$param</code>
    </MixedArgumentTypeCoercion>
    <MixedArrayAccess>
      <code>$overrides[$class_name]</code>
      <code><![CDATA[$overrides[$class_name][$method->getName()]]]></code>
      <code><![CDATA[$overrides[strtolower($class->getName())]]]></code>
      <code><![CDATA[$overrides[strtolower($class->getName())][$method->getName()]]]></code>
    </MixedArrayAccess>
    <MixedArrayOffset>
      <code><![CDATA[$overrides[$class_name][$method->getName()]]]></code>
      <code><![CDATA[$overrides[$class_name][$method->getName()]]]></code>
    </MixedArrayOffset>
    <MixedAssignment>
      <code>$class</code>
      <code>$code</code>
      <code>$defaultValue</code>
      <code>$overrides</code>
      <code>$overrides</code>
      <code>$paramDef</code>
    </MixedAssignment>
    <MixedInferredReturnType>
      <code>string</code>
    </MixedInferredReturnType>
    <MixedMethodCall>
      <code>getDeclaringClass</code>
      <code>getName</code>
      <code>getName</code>
      <code>getName</code>
      <code>getParameterOverrides</code>
      <code>getParameterOverrides</code>
      <code>getParameters</code>
      <code>getReturnType</code>
      <code>isStatic</code>
    </MixedMethodCall>
    <MixedOperand>
      <code>$code</code>
      <code>$paramDef</code>
      <code><![CDATA[$this->renderMethodBody($method, $config)]]></code>
      <code><![CDATA[$this->renderParams($method, $config)]]></code>
      <code><![CDATA[$this->renderReturnType($method)]]></code>
    </MixedOperand>
    <MixedReturnStatement>
      <code>$code</code>
    </MixedReturnStatement>
    <PossiblyFalseArgument>
      <code>$lastBrace</code>
    </PossiblyFalseArgument>
    <PossiblyUndefinedIntArrayOffset>
      <code>$matches[1]</code>
    </PossiblyUndefinedIntArrayOffset>
    <TypeDoesNotContainType>
      <code><![CDATA[strpos($param, '&') !== false]]></code>
    </TypeDoesNotContainType>
  </file>
  <file src="library/Mockery/Generator/StringManipulation/Pass/RemoveBuiltinMethodsThatAreFinalPass.php">
    <MissingPropertyType>
      <code>$methods</code>
    </MissingPropertyType>
    <MixedArgument>
      <code><![CDATA[$this->methods[$method->getName()]]]></code>
    </MixedArgument>
    <MixedArrayAccess>
      <code><![CDATA[$this->methods[$method->getName()]]]></code>
    </MixedArrayAccess>
  </file>
  <file src="library/Mockery/Generator/StringManipulation/Pass/RemoveUnserializeForInternalSerializableClassesPass.php">
    <MissingParamType>
      <code>$class</code>
      <code>$code</code>
    </MissingParamType>
    <MissingReturnType>
      <code>appendToClass</code>
    </MissingReturnType>
    <MixedArgument>
      <code>$class</code>
      <code>$class</code>
    </MixedArgument>
    <MixedInferredReturnType>
      <code>string</code>
    </MixedInferredReturnType>
    <MixedOperand>
      <code>$code</code>
    </MixedOperand>
    <MixedReturnStatement>
      <code><![CDATA[$this->appendToClass(
            $code,
            PHP_VERSION_ID < 80100 ? self::DUMMY_METHOD_DEFINITION_LEGACY : self::DUMMY_METHOD_DEFINITION
        )]]></code>
    </MixedReturnStatement>
    <PossiblyFalseArgument>
      <code>$lastBrace</code>
    </PossiblyFalseArgument>
  </file>
  <file src="library/Mockery/Generator/StringManipulationGenerator.php">
    <ArgumentTypeCoercion>
      <code>$className</code>
    </ArgumentTypeCoercion>
    <MissingThrowsDocblock>
      <code>new MockDefinition($namedConfig, $code)</code>
    </MissingThrowsDocblock>
    <PossiblyUnusedMethod>
      <code>addPass</code>
    </PossiblyUnusedMethod>
    <UnsafeInstantiation>
      <code>new static([
            new CallTypeHintPass(),
            new MagicMethodTypeHintsPass(),
            new ClassPass(),
            new TraitPass(),
            new ClassNamePass(),
            new InstanceMockPass(),
            new InterfacePass(),
            new AvoidMethodClashPass(),
            new MethodDefinitionPass(),
            new RemoveUnserializeForInternalSerializableClassesPass(),
            new RemoveBuiltinMethodsThatAreFinalPass(),
            new RemoveDestructorPass(),
            new ConstantsPass(),
            new ClassAttributesPass(),
        ])</code>
    </UnsafeInstantiation>
  </file>
  <file src="library/Mockery/Generator/TargetClassInterface.php">
    <PossiblyUnusedMethod>
      <code>getShortName</code>
      <code>inNamespace</code>
      <code>isAbstract</code>
    </PossiblyUnusedMethod>
  </file>
  <file src="library/Mockery/Generator/UndefinedTargetClass.php">
    <MoreSpecificImplementedParamType>
      <code>$interface</code>
    </MoreSpecificImplementedParamType>
  </file>
  <file src="library/Mockery/HigherOrderMessage.php">
    <MissingParamType>
      <code>$method</code>
    </MissingParamType>
    <MixedAssignment>
      <code>$expectation</code>
      <code><![CDATA[$this->method]]></code>
    </MixedAssignment>
    <MixedInferredReturnType>
      <code>Expectation|ExpectationInterface|HigherOrderMessage</code>
    </MixedInferredReturnType>
    <MixedMethodCall>
      <code>withArgs</code>
    </MixedMethodCall>
    <MixedReturnStatement>
      <code><![CDATA[$expectation->withArgs($args)]]></code>
      <code><![CDATA[$this->mock->{$this->method}($method, $args)]]></code>
    </MixedReturnStatement>
  </file>
  <file src="library/Mockery/Instantiator.php">
    <MissingClosureReturnType>
      <code>static function () use ($serializedString) {</code>
    </MissingClosureReturnType>
    <MissingThrowsDocblock>
      <code>attemptInstantiationViaUnSerialization</code>
      <code>getReflectionClass</code>
    </MissingThrowsDocblock>
    <MixedArgument>
      <code><![CDATA[static function ($code, $message, $file, $line) use ($reflectionClass, &$error): void {
            $msg = sprintf(
                'Could not produce an instance of "%s" via un-serialization, since an error was triggered in file "%s" at line "%d"',
                $reflectionClass->getName(),
                $file,
                $line
            );

            $error = new UnexpectedValueException($msg, 0, new Exception($message, $code));
        }]]></code>
    </MixedArgument>
    <MixedInferredReturnType>
      <code>TClass</code>
    </MixedInferredReturnType>
    <MixedReturnStatement>
      <code><![CDATA[$this->buildFactory($className)()]]></code>
    </MixedReturnStatement>
    <UndefinedVariable>
      <code>$error</code>
      <code>$error</code>
    </UndefinedVariable>
    <UnusedMethod>
      <code>hasInternalAncestors</code>
    </UnusedMethod>
  </file>
  <file src="library/Mockery/LegacyMockInterface.php">
    <PossiblyUnusedMethod>
      <code>byDefault</code>
      <code>makePartial</code>
      <code>mockery_allocateOrder</code>
      <code>mockery_findExpectation</code>
      <code>mockery_getCurrentOrder</code>
      <code>mockery_getGroups</code>
      <code>mockery_getMockableProperties</code>
      <code>mockery_init</code>
      <code>mockery_setCurrentOrder</code>
      <code>mockery_setExpectationsFor</code>
      <code>mockery_setGroup</code>
      <code>shouldAllowMockingMethod</code>
      <code>shouldAllowMockingProtectedMethods</code>
      <code>shouldDeferMissing</code>
      <code>shouldHaveBeenCalled</code>
      <code>shouldHaveReceived</code>
      <code>shouldNotHaveBeenCalled</code>
      <code>shouldNotHaveReceived</code>
    </PossiblyUnusedMethod>
  </file>
  <file src="library/Mockery/Loader/RequireLoader.php">
    <UnusedClass>
      <code>RequireLoader</code>
    </UnusedClass>
  </file>
  <file src="library/Mockery/Matcher/AndAnyOtherArgs.php">
    <DeprecatedClass>
      <code>MatcherAbstract</code>
    </DeprecatedClass>
  </file>
  <file src="library/Mockery/Matcher/Any.php">
    <DeprecatedClass>
      <code>MatcherAbstract</code>
    </DeprecatedClass>
  </file>
  <file src="library/Mockery/Matcher/AnyArgs.php">
    <DeprecatedClass>
      <code>MatcherAbstract</code>
    </DeprecatedClass>
  </file>
  <file src="library/Mockery/Matcher/AnyOf.php">
    <DeprecatedClass>
      <code>MatcherAbstract</code>
    </DeprecatedClass>
    <InvalidArgument>
      <code><![CDATA[$this->_expected]]></code>
    </InvalidArgument>
  </file>
  <file src="library/Mockery/Matcher/Closure.php">
    <DeprecatedClass>
      <code>MatcherAbstract</code>
    </DeprecatedClass>
    <InvalidFunctionCall>
      <code><![CDATA[($this->_expected)($actual)]]></code>
    </InvalidFunctionCall>
  </file>
  <file src="library/Mockery/Matcher/Contains.php">
    <DeprecatedClass>
      <code>MatcherAbstract</code>
    </DeprecatedClass>
    <MixedArgumentTypeCoercion>
      <code>$actual</code>
    </MixedArgumentTypeCoercion>
    <UndefinedClass>
      <code><![CDATA[$this->_expected]]></code>
      <code><![CDATA[$this->_expected]]></code>
    </UndefinedClass>
  </file>
  <file src="library/Mockery/Matcher/Ducktype.php">
    <DeprecatedClass>
      <code>MatcherAbstract</code>
    </DeprecatedClass>
    <InvalidArgument>
      <code><![CDATA[$this->_expected]]></code>
    </InvalidArgument>
    <UndefinedClass>
      <code><![CDATA[$this->_expected]]></code>
    </UndefinedClass>
  </file>
  <file src="library/Mockery/Matcher/HasKey.php">
    <DeprecatedClass>
      <code>MatcherAbstract</code>
    </DeprecatedClass>
    <InvalidArgument>
      <code><![CDATA[$this->_expected]]></code>
      <code><![CDATA[$this->_expected]]></code>
    </InvalidArgument>
  </file>
  <file src="library/Mockery/Matcher/HasValue.php">
    <DeprecatedClass>
      <code>MatcherAbstract</code>
    </DeprecatedClass>
    <InvalidCast>
      <code><![CDATA[$this->_expected]]></code>
    </InvalidCast>
  </file>
  <file src="library/Mockery/Matcher/IsEqual.php">
    <DeprecatedClass>
      <code>MatcherAbstract</code>
    </DeprecatedClass>
  </file>
  <file src="library/Mockery/Matcher/IsSame.php">
    <DeprecatedClass>
      <code>MatcherAbstract</code>
    </DeprecatedClass>
  </file>
  <file src="library/Mockery/Matcher/MatcherAbstract.php">
    <MixedPropertyTypeCoercion>
      <code>$expected</code>
    </MixedPropertyTypeCoercion>
    <PossiblyNullPropertyAssignmentValue>
      <code>null</code>
    </PossiblyNullPropertyAssignmentValue>
    <UndefinedDocblockClass>
      <code>TExpected</code>
      <code>protected $_expected = null;</code>
    </UndefinedDocblockClass>
  </file>
  <file src="library/Mockery/Matcher/MultiArgumentClosure.php">
    <DeprecatedClass>
      <code>MatcherAbstract</code>
    </DeprecatedClass>
    <InvalidFunctionCall>
      <code><![CDATA[($this->_expected)(...$actual)]]></code>
    </InvalidFunctionCall>
  </file>
  <file src="library/Mockery/Matcher/MustBe.php">
    <DeprecatedClass>
      <code>MatcherAbstract</code>
    </DeprecatedClass>
  </file>
  <file src="library/Mockery/Matcher/NoArgs.php">
    <DeprecatedClass>
      <code>MatcherAbstract</code>
    </DeprecatedClass>
    <MixedArgumentTypeCoercion>
      <code>$actual</code>
    </MixedArgumentTypeCoercion>
  </file>
  <file src="library/Mockery/Matcher/Not.php">
    <DeprecatedClass>
      <code>MatcherAbstract</code>
    </DeprecatedClass>
  </file>
  <file src="library/Mockery/Matcher/NotAnyOf.php">
    <DeprecatedClass>
      <code>MatcherAbstract</code>
    </DeprecatedClass>
    <UndefinedClass>
      <code><![CDATA[$this->_expected]]></code>
    </UndefinedClass>
  </file>
  <file src="library/Mockery/Matcher/Pattern.php">
    <DeprecatedClass>
      <code>MatcherAbstract</code>
    </DeprecatedClass>
    <InvalidArgument>
      <code><![CDATA[$this->_expected]]></code>
    </InvalidArgument>
    <InvalidCast>
      <code><![CDATA[$this->_expected]]></code>
    </InvalidCast>
  </file>
  <file src="library/Mockery/Matcher/Subset.php">
    <DeprecatedClass>
      <code>MatcherAbstract</code>
    </DeprecatedClass>
    <MissingPropertyType>
      <code>$strict</code>
    </MissingPropertyType>
    <MixedAssignment>
      <code>$v</code>
    </MixedAssignment>
    <PossiblyUnusedMethod>
      <code>loose</code>
      <code>strict</code>
    </PossiblyUnusedMethod>
    <UnsafeInstantiation>
      <code>new static($expected, false)</code>
      <code>new static($expected, true)</code>
    </UnsafeInstantiation>
  </file>
  <file src="library/Mockery/Matcher/Type.php">
    <DeprecatedClass>
      <code>MatcherAbstract</code>
    </DeprecatedClass>
    <DocblockTypeContradiction>
      <code><![CDATA[$this->_expected === 'real']]></code>
      <code><![CDATA[$this->_expected === 'real']]></code>
    </DocblockTypeContradiction>
    <InvalidArgument>
      <code><![CDATA[$this->_expected]]></code>
      <code><![CDATA[$this->_expected]]></code>
    </InvalidArgument>
    <InvalidCast>
      <code><![CDATA[$this->_expected]]></code>
    </InvalidCast>
    <MixedInferredReturnType>
      <code>bool</code>
    </MixedInferredReturnType>
    <MixedReturnStatement>
      <code>$function($actual)</code>
    </MixedReturnStatement>
    <NoValue>
      <code><![CDATA[$this->_expected]]></code>
    </NoValue>
    <PossiblyInvalidCast>
      <code><![CDATA[$this->_expected]]></code>
    </PossiblyInvalidCast>
    <RedundantConditionGivenDocblockType>
      <code><![CDATA['is_' . strtolower($this->_expected)]]></code>
      <code><![CDATA[is_string($this->_expected)]]></code>
    </RedundantConditionGivenDocblockType>
    <TypeDoesNotContainType>
      <code>function_exists($function)</code>
    </TypeDoesNotContainType>
  </file>
  <file src="library/Mockery/MethodCall.php">
    <PossiblyUnusedMethod>
      <code>__construct</code>
      <code>getArgs</code>
      <code>getMethod</code>
    </PossiblyUnusedMethod>
  </file>
  <file src="library/Mockery/MockInterface.php">
    <PossiblyUnusedMethod>
      <code>expects</code>
    </PossiblyUnusedMethod>
  </file>
  <file src="library/Mockery/ReceivedMethodCalls.php">
    <MissingPropertyType>
      <code>$methodCalls</code>
    </MissingPropertyType>
    <MissingReturnType>
      <code>push</code>
      <code>verify</code>
    </MissingReturnType>
    <MixedArgument>
      <code><![CDATA[$methodCall->getArgs()]]></code>
      <code><![CDATA[$methodCall->getArgs()]]></code>
    </MixedArgument>
    <MixedArrayAssignment>
      <code><![CDATA[$this->methodCalls[]]]></code>
    </MixedArrayAssignment>
    <MixedAssignment>
      <code>$methodCall</code>
    </MixedAssignment>
    <MixedMethodCall>
      <code>getArgs</code>
      <code>getArgs</code>
      <code>getMethod</code>
    </MixedMethodCall>
    <PossiblyUnusedMethod>
      <code>push</code>
    </PossiblyUnusedMethod>
  </file>
  <file src="library/Mockery/Reflector.php">
    <MissingThrowsDocblock>
      <code><![CDATA[throw new InvalidArgumentException('Unknown ReflectionType: ' . get_debug_type($type));]]></code>
    </MissingThrowsDocblock>
    <MixedArgument>
      <code>$innterType</code>
      <code><![CDATA[$type->getTypes()]]></code>
      <code><![CDATA[$type->getTypes()]]></code>
      <code>$typeHint</code>
    </MixedArgument>
    <MixedAssignment>
      <code>$innterType</code>
      <code>$type</code>
      <code>$type</code>
      <code>$typeHint</code>
    </MixedAssignment>
    <MixedReturnTypeCoercion>
      <code><![CDATA[[
                [
                    'typeHint' => $typeHint,
                    'isPrimitive' => in_array($typeHint, self::BUILTIN_TYPES, true),
                ],
            ]]]></code>
      <code><![CDATA[list<array{typeHint:string,isPrimitive:bool}>]]></code>
    </MixedReturnTypeCoercion>
    <PossiblyNullArgument>
      <code>$declaringClass</code>
    </PossiblyNullArgument>
    <PossiblyUnusedMethod>
      <code>getSimplestReturnType</code>
    </PossiblyUnusedMethod>
    <RedundantCondition>
      <code><![CDATA[! $type instanceof ReflectionType && method_exists($method, 'getTentativeReturnType')]]></code>
      <code><![CDATA[! $type instanceof ReflectionType && method_exists($method, 'getTentativeReturnType')]]></code>
    </RedundantCondition>
    <UndefinedMethod>
      <code>getName</code>
    </UndefinedMethod>
  </file>
  <file src="library/Mockery/Undefined.php">
    <PossiblyUnusedMethod>
      <code>__call</code>
    </PossiblyUnusedMethod>
    <PossiblyUnusedParam>
      <code>$args</code>
      <code>$method</code>
    </PossiblyUnusedParam>
  </file>
  <file src="library/Mockery/VerificationDirector.php">
    <MissingReturnType>
      <code>verify</code>
    </MissingReturnType>
    <PossiblyUnusedMethod>
      <code>atLeast</code>
      <code>atMost</code>
      <code>between</code>
      <code>once</code>
      <code>times</code>
      <code>twice</code>
      <code>with</code>
      <code>withAnyArgs</code>
      <code>withArgs</code>
      <code>withNoArgs</code>
    </PossiblyUnusedMethod>
  </file>
</files>
